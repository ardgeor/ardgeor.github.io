<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://0.0.0.0:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://0.0.0.0:4000/" rel="alternate" type="text/html" /><updated>2023-03-01T22:36:32+00:00</updated><id>http://0.0.0.0:4000/feed.xml</id><title type="html">Ardgeor’s</title><subtitle>Interests: reverse engineering, Android, ethical hacking, development, CTF, ...</subtitle><author><name>Gerardo Pinar Loriente</name></author><entry><title type="html">When Frida plays in the blue team</title><link href="http://0.0.0.0:4000/frida-can-play-in-the-blue-team/" rel="alternate" type="text/html" title="When Frida plays in the blue team" /><published>2023-02-28T00:00:00+00:00</published><updated>2023-02-28T00:00:00+00:00</updated><id>http://0.0.0.0:4000/frida-can-play-in-the-blue-team</id><content type="html" xml:base="http://0.0.0.0:4000/frida-can-play-in-the-blue-team/">&lt;!-- &lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/cover.png&quot;&gt;
&lt;/p&gt; --&gt;

&lt;p&gt;&lt;a href=&quot;https://eniit.es/defendiendose-de-exploits-de-desbordamiento-de-buffer/&quot;&gt;Pincha aquí para ver el artículo en español&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;We are used to see Frida as a valuable allied when we are on the attacker’s side. But Frida also happens to be a powerful partner when it comes to defending.
This article is about stack buffer overflow, a problem with a lot of history which is not past yet. 
Attack and defense methods have been competing for over 40 years, becoming more and more sophisticated: 
canaries, data execution prevention (DEP), return-oriented programming (ROP), address space layout randomization (ASLR), etc.&lt;/p&gt;

&lt;p&gt;Now let’s see one of the methods in which dynamic binary instrumentation (DBI) can help protect a vulnerable program.&lt;/p&gt;

&lt;h2 id=&quot;stack-buffer-overflow&quot;&gt;Stack buffer overflow&lt;/h2&gt;

&lt;p&gt;The stack buffer overflow problem appears whenever bytes are copied into a buffer with a limited size &lt;strong&gt;without having control on how many bytes are actually copied&lt;/strong&gt;.
In the snippet below, the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; receives data from the command line and passes it to the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt;, where the data is copied into the local variable
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt;. This variable corresponds to an array of 64 characters. Since &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt; is a local variable, it lives in the stack.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;processData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;---------------- BoF!&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Data processed: %s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// (...)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;processData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// (...)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;Let us take a closer look at what happens when a malicious input is passed. 
The image below corresponds to the moment right before the data is copied into the array &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt;, through the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt;.
This function takes its arguments from the stack: the destination address is on the top (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xffffcd60&lt;/code&gt;), and the source address is right after (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xffffd0db&lt;/code&gt;).
At the bottom of the picture, we can see the 64 bytes allocated for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;buffer&lt;/code&gt;, starting at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xffffcd60&lt;/code&gt;, 
and a little further down, there is the address to return from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x565556a9&lt;/code&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/before_strcpy.png&quot; /&gt;
&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;The following image corresponds to the moment when the execution has just returned from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;.
As it can be observed, data has been copied beyond the 64 bytes that had been assigned, the buffer has been overflowed.
As a result, the address to return from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; has changed into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf7f5674b&lt;/code&gt;, which has been placed there by
the attacker.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/bof.png&quot; /&gt;
&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;At this point, the execution flow has been redirected, which might entail arbitrary code execution. 
In the figure below, a shell with root privilege is shown, it was obtained as a result of the exploitation.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/exploit.png&quot; /&gt;
&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;Let us now digress a little to explain the concept of dynamic instrumentation, before focusing on how
it can help to thwart an exploit as the one we have just seen.&lt;/p&gt;

&lt;h2 id=&quot;dynamic-binary-instrumentation&quot;&gt;Dynamic binary instrumentation&lt;/h2&gt;

&lt;p&gt;Dynamic binary instrumentation can be defined as &lt;a href=&quot;https://www.cs.tufts.edu/comp/150PAT/tools/caliper/epic1.pdf&quot;&gt;the process of modifying the instructions of a binary 
program while it executes&lt;/a&gt;.&lt;/p&gt;

&lt;!-- RAMASAMY, Vinodha; HUNDT, Robert. Dynamic binary instrumentation on IA-64. En Proceedings of the First EPIC Workshop. 2001. --&gt;

&lt;h3 id=&quot;frida&quot;&gt;Frida&lt;/h3&gt;
&lt;p&gt;One of the most popular tools for DBI over the past few years is &lt;a href=&quot;https://frida.re/&quot;&gt;Frida&lt;/a&gt;. 
It is used by developers, reverse-engineering professionals and security researchers.
Frida is powerful, flexible and easy to use. We can work through scripts, it is multi-platform, free software and widely tested. 
It is no coincidence that a large number of projects and tools have been developed on top of Frida, as it provides an excellent 
base.&lt;/p&gt;

&lt;h4 id=&quot;the-interceptor&quot;&gt;The Interceptor&lt;/h4&gt;
&lt;p&gt;The Frida &lt;a href=&quot;https://frida.re/docs/javascript-api/#interceptor&quot;&gt;Interceptor&lt;/a&gt; allows, among other things, to set hooks 
on functions and implement callbacks where we can specify actions to be carried out before and after the “hooked” function is executed.
The actions to perform &lt;strong&gt;before&lt;/strong&gt; are defined in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onEnter&lt;/code&gt; callback, and the actions to perform &lt;strong&gt;after&lt;/strong&gt; are defined in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onLeave&lt;/code&gt; callback.&lt;/p&gt;

&lt;p&gt;The Javascript code for using the Interceptor would have a structure as follows, where the target can be a function name or address:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Interceptor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// actions to be carried out before executing the target function&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (...)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onLeave&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;retval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// actions to be carried out after the execution of the target function&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (...)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;This magic is possible thanks to a mechanism called “trampoline”. Explained in a few words, it simply consists in replacing the
first instructions of the target function by others to jump into a controlled area where to jump to 
specific areas of injected code and, at the end, place
the removed instructions and jump back to the function code:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/frida_interceptor_trampoline.png&quot; /&gt;
&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;Now we are ready to go for the interesting part! :)&lt;/p&gt;

&lt;h2 id=&quot;shielding-the-return-address&quot;&gt;Shielding the return address&lt;/h2&gt;

&lt;p&gt;Let us get back to the moment when the first instruction of the function &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; is going to be executed. 
At this point, the address to return from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x5655560f&lt;/code&gt;) is on the top of the stack.
A few positions further down, there is the address to return from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt; to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x565556a9&lt;/code&gt;).
Note that no instruction from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; has been executed yet; thus, the register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EBP&lt;/code&gt; is still pointing to the
base of the stack frame for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;processData&lt;/code&gt;, this is, right on top of the address to return to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/algo_hook_01.png&quot; /&gt;
&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;We we discussed above about the concept of buffer overflow, we differentiated between two key moments: 
(1) the instant before &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt; was executed, and (2) right afterwards. 
These two moments are depicted in the following image: at the top, before executing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt;; 
at the bottom, after executing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;strcpy&lt;/code&gt;. 
Note that, in the former case, the address to return to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; is the legitimate one (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0x565556a9&lt;/code&gt;); whereas in the latter case, 
the address has been altered by the exploit (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xf7f568ab&lt;/code&gt;). How could we avoid this? If it were possible for us to , somehow, 
do actions at these two precise moments, we could first read the 4 bytes of the return address, stored at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xffffcd9c&lt;/code&gt;, 
and read it again in the second moment. If the two read values were different, we would have detected the buffer overflow 
and we could abort the execution of the program. 
Regarding the address where the address to return to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; is stored, this could be obtained from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EBP&lt;/code&gt; register, since it points to 
the 4 bytes preceding the return address.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/algo_hook_02.png&quot; /&gt;
&lt;/p&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;So we have two moments where we would like to act… Is that even possible? If we recall what we have seen about Frida and the Interceptor, we will
realize that it is. The Interceptor gives us the opportunity to take action before and after the execution of the “hooked” function, 
which can be done by writing out code within the callbacks &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onEnter&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onLeave&lt;/code&gt;, respectively.&lt;/p&gt;

&lt;p&gt;The snippet below shows a minimalist implementation of the algorithm:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onEnter&lt;/code&gt; block, the address where the address to return to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; is located is referred to as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.callerRetAddrPtr&lt;/code&gt;. It is obtained from the register &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EBP&lt;/code&gt;, 
as it is placed 4 bytes after. This address was represented as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;amp;a&lt;/code&gt; in the previous image. Next, if we dereference the pointer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.callerRetAddrPtr&lt;/code&gt;, 
we obtain the address to return to main, which is stored in the variable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.originalCallerRetAddr&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;In the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onLeave&lt;/code&gt; block, the pointer &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.callerRetAddrPtr&lt;/code&gt; is again dereferenced and the value obtained, 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;callerRetAddrBeforeRet&lt;/code&gt;, is compared with the value of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this.originalCallerRetAddr&lt;/code&gt;.
If they differ, a buffer overflow has been detected and the execution can be aborted.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;
&lt;/pre&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Interceptor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getExportByName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onEnter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callerRetAddrPtr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ebp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;originalCallerRetAddr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callerRetAddrPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;onLeave&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;retval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callerRetAddrBeforeRet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Memory&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;readPointer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callerRetAddrPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;originalCallerRetAddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callerRetAddrBeforeRet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// abort&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;/pre&gt;

&lt;p&gt;In the picture below, we can observe how the application of this strategy results in the neutralization of the exploit, which does not return a shell.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/frida_blue_team/exploitation_prevention.png&quot; /&gt;
&lt;/p&gt;

&lt;h2 id=&quot;what-else&quot;&gt;What else?&lt;/h2&gt;

&lt;p&gt;If you feel like playing with this PoC, you can check out the git repository &lt;a href=&quot;https://github.com/ardgeor/retShield&quot;&gt;retShield&lt;/a&gt;.&lt;/p&gt;</content><author><name>Gerardo Pinar Loriente</name></author><category term="Frida" /><category term="Dynamic instrumentation" /><category term="Exploiting" /><category term="Stack buffer overflow" /><category term="Defence" /><summary type="html">Let's see how to protect a vulnerable binary against stack buffer overflow attacks through dynamic instrumentation.</summary></entry><entry><title type="html">Why you should also protect the integrity of the native libraries</title><link href="http://0.0.0.0:4000/abusing-shared-object-in-android-applications/" rel="alternate" type="text/html" title="Why you should also protect the integrity of the native libraries" /><published>2023-01-16T00:00:00+00:00</published><updated>2023-01-16T00:00:00+00:00</updated><id>http://0.0.0.0:4000/abusing-shared-object-in-android-applications</id><content type="html" xml:base="http://0.0.0.0:4000/abusing-shared-object-in-android-applications/">&lt;!-- &lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/cover.png&quot;&gt;
&lt;/p&gt; --&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Nowadays, the developers of mobile applications handling sensitive information are usually aware of the security risks. 
Open-source and commercial solutions are involved during the build process, providing obfuscation and protections against techniques such as 
tampering, dynamic instrumentation, debugging, rooting, emulation, etc. These protection techniques have significantly evolved 
in the last years. Thus, bypassing these mechanisms usually requires advanced reverse engineering skills.&lt;/p&gt;

&lt;p&gt;However, there are still security holes that should not be overlooked, as they become low-hanging fruit that can be aimed by not necessarily
highly skilled attackers.&lt;/p&gt;

&lt;p&gt;An example of how what could be a banking application could be compromised is discussed in this article.&lt;/p&gt;

&lt;p&gt;This article is written with the purpose of raising awareness about the importance of taking care of the small details when developing products.
A huge defensive system might become useless if we leave an open window somewhere.&lt;/p&gt;

&lt;h2 id=&quot;proof-of-concept-poc&quot;&gt;Proof of Concept (PoC)&lt;/h2&gt;

&lt;h3 id=&quot;the-target-application-an-impregnable-bastion&quot;&gt;The target application: an impregnable bastion&lt;/h3&gt;

&lt;p&gt;For this demonstration, the target will be an application which requires entering a PIN code to authenticate a user.
The activity than contains the PIN pad is protected against screen captures through the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Java&quot;&gt;
 window.setFlags(WindowManager.LayoutParams.FLAG_SECURE, 
      WindowManager.LayoutParams.FLAG_SECURE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The explanation of the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; from the 
&lt;a href=&quot;https://developer.android.com/reference/android/view/WindowManager.LayoutParams#FLAG_SECURE&quot;&gt;Android development site&lt;/a&gt;
is shown below:&lt;/p&gt;

&lt;!-- &lt;img src=&quot;/assets/images/abusing_shared_object/flag_secure.png&quot; width=&quot;1000&quot;&gt; --&gt;
&lt;p align=&quot;left&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/flag_secure.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Hence, when this flag is set, capturing the screen is not allowed by the system. 
For instance, if we try to record the screen it will be shown in black; 
and if we try to take a screenshot through a button combination, it will not be allowed 
and a message like the one in the picture below will be shown:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/failed_screenshot.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Furthermore, the application does not allow to proceed if the developer options are enabled (&lt;a href=&quot;https://developer.android.com/studio/command-line/adb&quot;&gt;adb&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Let us suppose that this application is protected with state-of-the-art techniques against rooting, hooking, debugging, tampering, etc.&lt;/p&gt;

&lt;p&gt;Thus, any attempt to hook or tamper with the APK would eventually trigger a security check, preventing the application from running in normal conditions.&lt;/p&gt;

&lt;p&gt;Let us also accept that the application is strongly obfuscated, and trying to understand how the security checks work would entail an arduous process of reverse engineering, which requires high skills.&lt;/p&gt;

&lt;h3 id=&quot;an-open-window-through-the-fortress&quot;&gt;An open window through the fortress&lt;/h3&gt;

&lt;p&gt;However, all this defensive effort described above might be in vain, as there is a small hole that leads inside of the fortress: the application has a native library whose integrity is not totally protected: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt;.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/libvuln.so.png&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;loading-a-malicious-native-library&quot;&gt;Loading a malicious native library&lt;/h3&gt;

&lt;p&gt;The fact that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; can be modified without being detected, means that we could potentially alter the behaviour of the application. Moreover, the library &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; is loaded before the PIN pad is used. Hence, any modification we might induce, would be effective at the moment when the PIN pad is being used.&lt;/p&gt;

&lt;p&gt;Where to begin? Let us imagine that we have a rogue library, called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt;, which contains some malicious functions that we would like to be executed by the target application. Would it be possible? Well, the first problem to solve is that we need this library to be loaded in memory. In order to achieve this, the library &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; could be modified to declare an additional library as a dependency and, hence, make it to be loaded. This can be done with a tool called &lt;a href=&quot;https://github.com/lief-project/LIEF&quot;&gt;LIEF&lt;/a&gt;, created by the security engineer &lt;a href=&quot;https://www.romainthomas.fr/&quot;&gt;Romain Thomas&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As depicted below, LIEF takes as input the library to modify, and the name of the library to add as a dependency. The binary produced as a result, will include the name &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt; as a needed library.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/lief.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;The code to produce this is shown below:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;lief&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# (...)
&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;libnative&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lief&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}/{}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so_input_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;so_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;libnative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_library&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so_inject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# Injection!
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;libnative&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{}/{}&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;format&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;so_output_path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;so_output&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By inspecting the strings of the binary produced, we can confirm that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt; had been added to the list of libraries to load:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/strings_dep_added.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;In Android, the libraries embedded in an APK are placed within a directory dedicated for the specific application in the path &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/data/app&lt;/code&gt;. For our case, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; is placed in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/data/app/ardgeor.libabuse.poc.targetapp-1/lib/arm64&lt;/code&gt;. For our attack, we would simply replace &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; by the “liefed” version. We would also copy &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt; in the same directory.&lt;/p&gt;

&lt;p&gt;At this point, there are two aspects that need to be clarified:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Of course, we need to be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;root&lt;/code&gt; in order to write in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/data/app&lt;/code&gt;. However, this does not necessarily entail to bypass the root protection, as this action can be carried out when the application is not running. Thus, it would be enough for an attacker to just temporarily elevate privileges.&lt;/li&gt;
  &lt;li&gt;Actually, the native libraries are placed in the directory for the application in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/data/app&lt;/code&gt; as long as the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;android:extractNativeLibs&lt;/code&gt; is not set to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;false&lt;/code&gt; in the Android manifest. However, if we place the modified version of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; in this directory, this will be the binary loaded in memory, as that’s the preferred location.&lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/lib_injection.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Once the libraries have been placed in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/data/app/ardgeor.libabuse.poc.targetapp-1/lib/arm64&lt;/code&gt;, we can launch the application. 
A message in the log reveals that the library &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt; is executing. No disruptive action is observed. At this point, we can inject our own code in the application and get it executed.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/librogue_loaded.png&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;loading-a-malicious-dex-file&quot;&gt;Loading a malicious DEX file&lt;/h3&gt;

&lt;p&gt;So, we are already able to execute the code from our own native library. What would we like to do at this point?&lt;/p&gt;

&lt;p&gt;Thinking as an attacker about a real scenario, it would be great to disable the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; on the PIN activity and add functionality to take screenshots or record the screen, as well as support to send information to a server controlled by the attacker. As we plan to make calls at the Java layer, it would be more convenient to write Java code, generate a DEX file and load it from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt;.
The article &lt;a href=&quot;https://erev0s.com/blog/3-ways-for-dynamic-code-loading-in-android/&quot;&gt;&lt;em&gt;Three ways for dynamic code loading in Android&lt;/em&gt;&lt;/a&gt; may serve as inspiration for loading the DEX.&lt;/p&gt;

&lt;p&gt;Thus, Java reflection calls were included in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt; to use, through the JNI, the class &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DexClassLoader&lt;/code&gt; for loading our DEX &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rogue.dex&lt;/code&gt;. This is shown in the log snippet below:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/load_dex.png&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;enabling-screen-captures&quot;&gt;Enabling screen captures&lt;/h3&gt;

&lt;p&gt;Good! Now we can inject code both in the native layer and in the Java layer!&lt;/p&gt;

&lt;p&gt;Our goal was to disable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; on the PIN activity. 
A simple approach could be to iteratively recover the current activity and disable the flag. 
This can be done through reflection calls to specific hidden Android API.
The result can be observed in the log snippet below:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/disable_flag_secure.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;And now we can capture the screen :)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/screenshot.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;We could summarize this first part in three steps, as shown in the picture below:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Modify &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;libvuln.so&lt;/code&gt; to indicate that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt; needs to be loaded.&lt;/li&gt;
  &lt;li&gt;From &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;librogue.so&lt;/code&gt;, load &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rogue.dex&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;From &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rogue.dex&lt;/code&gt;, recover the current activity and clear the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; from the corresponding window object.&lt;/li&gt;
&lt;/ol&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/attack_outline.png&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;capturing-the-pin&quot;&gt;Capturing the PIN&lt;/h3&gt;

&lt;p&gt;We have seen how it was possible to disable the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; and take screenshots or record the screen. 
At this point there are different possibilities, let us go across them and analyze each particular case&lt;/p&gt;

&lt;h4 id=&quot;the-pin-pad-provides-a-visual-feedback-when-a-button-is-pressed&quot;&gt;The PIN pad provides a visual feedback when a button is pressed&lt;/h4&gt;

&lt;p&gt;The easiest case for the attacker would be when a visual feedback is produced when pressing a button of the PIN pad.
For instance, from the screen shown in the figure below, we can know that the button &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt; was pressed, as a shadow appeared on the button.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/visual_fb_button_pressed.png&quot; /&gt;
&lt;/p&gt;

&lt;h4 id=&quot;the-pin-pad-does-not-provide-a-visual-feedback-when-a-button-is-pressed&quot;&gt;The PIN pad does not provide a visual feedback when a button is pressed&lt;/h4&gt;

&lt;p&gt;In the case that no visual effect is produced, such as a shadow or a color change, just being able to observe the screen would not be enough for an attacker to 
obtain the PIN. 
An additional capability will be required, related to where the user touched on the screen.&lt;/p&gt;

&lt;p&gt;There exists a feature that satisfies this need: the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option, or “show taps”. This can be enabled through the developer options menu:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/show_taps.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;This apparently solved the problem, except that we had said that the application did not allow the developer options to be enabled…&lt;/p&gt;

&lt;h5 id=&quot;enabling-the-show_touches-feature-without-the-developer-options&quot;&gt;Enabling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; feature without the developer options&lt;/h5&gt;

&lt;p&gt;But we had also mentioned that this attack needs the ability to temporarily become root. A root privilege allows to activate the 
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; setting. However, a shell session &lt;strong&gt;independent from ADB&lt;/strong&gt; is needed.&lt;/p&gt;

&lt;p&gt;Let us think again of a real scenario, let’s imagine an attacker that has a remote shell session on the phone through e.g. using the SSH protocol.
The attacker must become root, and the privilege obtained must allow to edit the settings. 
If this is achieved, the following command will activate the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;se&quot;&gt;\#&lt;/span&gt;  content insert &lt;span class=&quot;nt&quot;&gt;--uri&lt;/span&gt; content://settings/system &lt;span class=&quot;nt&quot;&gt;--bind&lt;/span&gt; name:s:show_touches &lt;span class=&quot;nt&quot;&gt;--bind&lt;/span&gt; value:i:1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;or also:&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;se&quot;&gt;\#&lt;/span&gt;  settings put system show_touches 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A couple of comments about this:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If the phone reboots, the change is persistent, meaning that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option will still be active.&lt;/li&gt;
  &lt;li&gt;If the developer options are enabled, and then disabled, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option will be disabled.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Well, at this point nothing prevents us from capturing the PIN, as shown in the picture below, where a tap appears on the digit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2&lt;/code&gt;:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/capture_touch.png&quot; /&gt;
&lt;/p&gt;

&lt;h4 id=&quot;further-discussion&quot;&gt;Further discussion&lt;/h4&gt;

&lt;p&gt;There are more possibilities that could make the attack unfeasible or even easier. 
For instance, if the position of the buttons is always the same, we don’t really need to * see * the PIN pad, it is enough to see the taps, and 
then derive the button that was pressed.&lt;/p&gt;

&lt;p&gt;Let us see an example. The screen shown below has been captured. As we can see, the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; has not be disabled, but the
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option has been enabled.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/not_visible.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;If the position of the buttons is static, we can just superimpose a template of the PIN pad on the screen capture, and we obtain the button that was pressed. 
Or we can directly infer it from the screen capture :)&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/not_visible_with_template.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;A more complicated case would be when there is no visual feedback and also the position of the buttons is not predictable. 
In this case, we would again need both disabling the flag &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt;, in order to see where each button is placed; 
and also enable the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option, to obtain visual feedback. An example is shown below:&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/unpredictable.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;Finally, if the application checks the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option and refuses to execute normally if it is enabled; and there is no visual feedback on the PIN pad; then, in this case, retrieving the PIN from the screen is, a priori, not possible.&lt;/p&gt;

&lt;p&gt;The relevant cases are summarized in the table below:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; enabled&lt;/th&gt;
      &lt;th&gt;PIN pad buttons at a fixed position&lt;/th&gt;
      &lt;th&gt;Visual feedback&lt;/th&gt;
      &lt;th&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; detected&lt;/th&gt;
      &lt;th&gt;Attack path&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt;Disable &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Activate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Not needed&lt;/td&gt;
      &lt;td&gt;Not needed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Not needed&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Not needed&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;N/A&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;X&lt;/td&gt;
      &lt;td&gt;No&lt;/td&gt;
      &lt;td&gt;Yes&lt;/td&gt;
      &lt;td&gt;Attack not possible&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;summing-up&quot;&gt;Summing up&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;The attack paths presented here take advantage from neglected security holes. 
Namely, absence of integrity checks on the shared objects (*.so), and absence of a explicit check on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option to be disabled
(just a check on the developer options is not enough!).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The attack requires a shell session as root. Actions will be carried out when the target application is not in use, so no need to worry about security checks (depending on how root has been obtained).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Depending on the exact case (see the different cases discussed above), different additional requirements would be needed for the attack to be applicable:
    &lt;ul&gt;
      &lt;li&gt;If disabling the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FLAG_SECURE&lt;/code&gt; flag is required, an unprotected shared object (being loaded before the PIN pad is used) is needed.&lt;/li&gt;
      &lt;li&gt;If the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;show_touches&lt;/code&gt; option is needed, the attack privilege must allow to edit the system settings. Moreover, a shell session &lt;strong&gt;not related to ADB&lt;/strong&gt; is needed.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The attack can apply to any application, without customization, as long as the required conditions are fulfilled.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;No reverse engineering is required.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;what-else&quot;&gt;What else?&lt;/h2&gt;

&lt;p&gt;Note that if we are able to inject code, this opens the door to new attacks :)&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Keep thinking about security, don’t take it for granted.&lt;/li&gt;
  &lt;li&gt;Pay attention to the small details. Is there an easy way in somewhere?&lt;/li&gt;
  &lt;li&gt;Keep this picture in sight:&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/abusing_shared_object/breach.png&quot; /&gt;
&lt;/p&gt;</content><author><name>Gerardo Pinar Loriente</name></author><category term="Android" /><category term="Tampering" /><category term="Injection" /><category term="Bypass" /><summary type="html">In this article we will see how a native library can be abused to inject code and capture the PIN code from an Android application, without triggering the protections. All without doing reverse engineering.</summary></entry></feed>